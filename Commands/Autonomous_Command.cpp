// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Autonomous_Command.h"
#include "AutoMode_1_FireDriveToZone.h"
#include "Auto_ShootDrive.h"
Autonomous_Command::Autonomous_Command() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	 
	//Need to manually add all of the other subsystems
    Requires(Robot::claw);
    Requires(Robot::turretWithPID);
    Requires(Robot::driveWithPID);
    autoCommand1 = new AutoMode_1_FireDriveToZone(false);
    autoCommand2 = new Auto_ShootDrive();
}
Autonomous_Command::~Autonomous_Command()
{
    delete autoCommand1;
    delete autoCommand2;
}
// Called just before this Command runs the first time
void Autonomous_Command::Initialize() {
    int autoMode = Robot::oi->getAutoMode();
//    std::cout << "Autonomous_Command::Initialize - using Auto Mode " << autoMode << std::endl;
    //This switch statement will determine which Auto Mode will run
//    if(Robot::turretWithPID->isAngleValid() && Robot::armPitchWithPID->isAngleValid())
//    {
        //TODO: Check if the a low turret angle is facign left or right.
//        bool facingLeftGoal = (Robot::turretWithPID->getCurrentAngle() < 90.0 ? true : false);
    switch(autoMode)
    {
    case 1:
    default:
    	autoCommand1->Start();
    	break;
    case 2:
    	autoCommand2->Start();
    	break;
    }
    //}
    //else, just fire ball
}
       
// Called repeatedly when this Command is scheduled to run
void Autonomous_Command::Execute() {
	
}
// Make this return true when this Command no longer needs to run execute()
bool Autonomous_Command::IsFinished() {
    //TODO: Dont' know if this can be set to true right away, 
    //or if we need to check whether or not the Auto Mode has finished.
	return false;
}
// Called once after isFinished returns true
void Autonomous_Command::End() {
//    delete autoCommand;
//        autoCommand = NULL;
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void Autonomous_Command::Interrupted() {
}
