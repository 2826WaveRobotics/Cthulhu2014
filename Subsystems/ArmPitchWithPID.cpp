
// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ArmPitchWithPID.h"
#include "../Robotmap.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"
#include <math.h>
#include "../WaveConstants.h"
#include "../Commands/ArmPitchByJoystick.h"
//using namespace SensorOffsets;
namespace
{
    //0 degrees is horizontal, 90 degrees is vertical. ex. If 180 degress is horizontal, g_ArmAngleDifference = 180
    const double c_ArmAngleDifference = 184; // 186
    const double c_sensorVoltRange = 4.0; //Valid range is 0.5 -> 4.5
    const double c_sensorAngleRange = 360.0; //This is the movement allowed in the arm
    const double c_sensorAngleTolerance = 1.0; // 1 degree
    
    //PID Controller Constants
    const double c_downP = 3.5;
    const double c_downI = 0.00;
    const double c_downD = 0.00;
    const double c_downF = 0.0;
    const bool   c_useDownF = false;
    
    const double c_upP = 9;
    const double c_upI = 0.0;
    const double c_upD = 0.0;
    const double c_upF = 0.0;
    const bool   c_useUpF = false;
}
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ArmPitchWithPID::ArmPitchWithPID() : PIDSubsystem("ArmPitchWithPID", 0.5, 0.0, 0.0) {
	SetAbsoluteTolerance(0.1);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("ArmPitchWithPID", "PIDSubsystem Controller", GetPIDController());
	GetPIDController()->SetInputRange(0.5, 4.5);
	GetPIDController()->SetOutputRange(-1.0, 1.0);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	pitchMotor = RobotMap::armPitchWithPIDPitchMotor;
	pitchAngleSensor = RobotMap::armPitchWithPIDPitchAngleSensor;
	pitchAngleSensorInverted = RobotMap::armPitchWithPIDPitchAngleSensorInverted;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
	//SetSetpoint(c_armShootPosition);
	
	
	m_requestedAngle = 90;
	isAngleValid(); //sets m_actualAngle
}
double ArmPitchWithPID::ReturnPIDInput() {
	// Return your input value for the PID loop
	// e.g. a sensor, like a potentiometer:
	// yourPot->SetAverageVoltage() / kYourMaxVoltage;	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return pitchAngleSensor->GetAverageVoltage();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
}
void ArmPitchWithPID::UsePIDOutput(double output) {
    output = -output; //Arm motors are inverted
    
    //Limit the acceleration
    if(output > 0.8)
    {
        output = 0.8;
    }
    else if(output < -0.8)
    {
        output = -0.8;
    }
    
	// Use output to drive your system, like a motor
	// e.g. yourMotor->Set(output);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	pitchMotor->PIDWrite(output);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
}
void ArmPitchWithPID::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//setDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new ArmPitchByJoystick());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
double ArmPitchWithPID::getPIDOutput()
{
    return GetPIDController()->Get();
}
void ArmPitchWithPID::setAbsoluteAngle(double angle)
{
    
    PIDController *pid = GetPIDController();
    double currentAngle = getCurrentAngle();
    
    if(angle < currentAngle)
    {
        //These are DOWN gains
        if(c_useDownF)
        {
            pid->SetPID(c_downP, c_downI, c_downD, c_downF);
        }
        else
        {
            pid->SetPID(c_downP, c_downI, c_downD);
        }
    }
    else
    {
        //These are UP gains
        if(c_useUpF)
        {
            pid->SetPID(c_upP, c_upI, c_upD, c_upF);
        }
        else
        {
            pid->SetPID(c_upP, c_upI, c_upD);
        }
    }
    
    double setVoltage = convertAngleToVolts(angle, false);
    
    pid->Reset();
    pid->SetSetpoint(setVoltage);
    pid->Enable();
    m_requestedAngle = angle;
}
double ArmPitchWithPID::convertAngleToVolts(double angle, bool inverted)
{
	if(inverted){
		return (((c_sensorVoltRange/c_sensorAngleRange)*(360-angle+c_ArmAngleDifference))+.5);
	}
	else{
		return (((c_sensorVoltRange/c_sensorAngleRange)*(angle + c_ArmAngleDifference))+.5);
	}
}
double ArmPitchWithPID::convertVoltsToAngle(double volts, bool inverted)
{
    double angle;
	if(inverted){
		angle = ((c_sensorAngleRange/c_sensorVoltRange)*(4.5-volts)) - c_ArmAngleDifference;
	}
	else{
		angle = (((c_sensorAngleRange/c_sensorVoltRange)*(volts-.5))) - c_ArmAngleDifference;
	}
	return angle;
}
double ArmPitchWithPID::getCurrentAngle() {
//	return m_actualAngle;
    return convertVoltsToAngle(pitchAngleSensor->GetAverageVoltage(), false);
}
bool ArmPitchWithPID::isAngleValid() {
	float volts = pitchAngleSensor->GetAverageVoltage();
	float invertedVolts = pitchAngleSensorInverted->GetAverageVoltage();
	if((volts < .5) || (volts > 4.5) || (invertedVolts < .5) || (invertedVolts > 4.5))
	{
//	    std::cout << "  ArmPitchWithPID::isAngleValid -- Sensor Out of Range" << std::endl;
		m_angleInputValid = false;
	}
	else
	{
	    m_angleInputValid = true;
	}
    return m_angleInputValid;
    //double angle = convertVoltsToAngle(volts, false);
	//double invertedAngle = convertVoltsToAngle(invertedVolts, true);
    //std::cout << "  ArmPitchWithPID::isAngleValid -- angle= " << angle << ", invert= " << invertedAngle;
//	if(fabs(angle-invertedAngle) < c_sensorAngleTolerance)
//	{
////	    std::cout << " : Valid" << std::endl;
//		m_angleInputValid = true;
//		m_actualAngle = ((angle+invertedAngle)/2);
//	}
//	else
//	{
////        std::cout << " : NOT Valid" << std::endl;
//		m_angleInputValid = false;
//	}
//	return m_angleInputValid;
}
void ArmPitchWithPID::setPitchMotorOutput(double output){
//    isAngleValid();
    float angle = getCurrentAngle();
    //std::cout << "Arm Angle: " << angle << ", Requested Output: " << output;
    //std::cout << "Arm Angle: " << angle << ", rawVolts: " << pitchAngleSensor->GetAverageVoltage() << ", calcVolts: " << convertAngleToVolts(angle, false) << std::endl;
    //Note: Up on the joystick/Arm is a negative output.
    if((angle > c_pitchAngleMax) && (output > 0)){ //276 degrees
        pitchMotor->Set(output);
    }
    else if((angle < c_pitchAngleMin) && (output < 0)){ //186 degrees
        pitchMotor->Set(output);
    }
    else if((angle <= c_pitchAngleMax) && (angle >= c_pitchAngleMin)){
        pitchMotor->Set(output);
    }
    else{
//        std::cout << "Not allowing output" << std::endl;
        pitchMotor->Set(0);
    }
//        std::cout << " \tOutput: " << output << std::endl;
}
void ArmPitchWithPID::setPitchMotorAngle(double degrees){
    
    double targetAngle = degrees;
    double currentAngle = getCurrentAngle();
    double output;
    
    output = targetAngle;
    
    UsePIDOutput(output);
}
