#include "TurretWithPID.h"
#include "../Robotmap.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"
#include <math.h>
#include "../WaveConstants.h"
#include "../Commands/TurretByJoystick.h"
//using namespace SensorOffsets;
namespace
{
//0 degrees is left-face, 180 degrees is right-face. ex. If 45 degress is left-face, g_ArmAngleDifference = 45
const double c_TurretAngleDifference = 89; // 99
		
const double c_sensorVoltRange = 4.0; //Valid range is 0.5 -> 4.5
const double c_sensorAngleRange = 360.0; //This is the swing allowed in the turret
const double c_sensorAngleTolerance = .002; // degrees


//PID Controller Constants
const double c_turnP = 6.0;
const double c_turnI = .5;
const double c_turnD = 0.00;
const double c_turnF = 0.0;
const bool   c_useTurnF = false;
}
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
TurretWithPID::TurretWithPID() : PIDSubsystem("TurretWithPID", 1.0, 0.0, 0.0) {
	SetAbsoluteTolerance(0.1);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("TurretWithPID", "PIDSubsystem Controller", GetPIDController());
	GetPIDController()->SetInputRange(0.5, 4.5);
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	turretAngleSensor = RobotMap::turretWithPIDTurretAngleSensor;
	turretAngleSensorInverted = RobotMap::turretWithPIDTurretAngleSensorInverted;
	turretMotor = RobotMap::turretWithPIDTurretMotor;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
	m_requestedAngle = 100; // 90
	isAngleValid(); // sets m_actualAngle
}
double TurretWithPID::ReturnPIDInput() {
	return turretAngleSensor->GetAverageVoltage();
}
void TurretWithPID::UsePIDOutput(double output) {
	//Limit the acceleration
	if(output > 0.8)
	{
		output = 0.8;
	}
	else if(output < -0.8)
	{
		output = -0.8;
	}
	turretMotor->PIDWrite(output);
}
void TurretWithPID::InitDefaultCommand() {
	SetDefaultCommand(new TurretByJoystick());
}
double TurretWithPID::getPIDOutput()
{
	return GetPIDController()->Get();
}
void TurretWithPID::setAbsoluteAngle(double angle)
{
	PIDController *pid = GetPIDController();
	if(c_useTurnF)
	{
		pid->SetPID(c_turnP, c_turnI, c_turnD, c_turnF);
	}
	else
	{
		pid->SetPID(c_turnP, c_turnI, c_turnD);
	}

	double setVoltage = convertAngleToVolts(angle, false);
	pid->Reset();
	pid->SetSetpoint(setVoltage);
	pid->Enable();
	m_requestedAngle = angle;
}
double TurretWithPID::convertAngleToVolts(double angle, bool inverted)
{
	if(inverted){
		return ((c_sensorVoltRange/c_sensorAngleRange)*(360-angle+c_TurretAngleDifference)+.5);
	}
	else{
		return (((c_sensorVoltRange/c_sensorAngleRange)*(angle+c_TurretAngleDifference))+.5);
	}
}
double TurretWithPID::convertVoltsToAngle(double volts, bool inverted)
{
	double angle;
	if(inverted){
		angle = ((c_sensorAngleRange/c_sensorVoltRange)*(4.5-volts)) - c_TurretAngleDifference;
	}
	else{
		angle = (((c_sensorAngleRange/c_sensorVoltRange)*(volts-.5))) - c_TurretAngleDifference;
	}
	return angle;
}
double TurretWithPID::getCurrentAngle() {
	return convertVoltsToAngle(turretAngleSensor->GetAverageVoltage(), false);
}
bool TurretWithPID::isAngleValid() {
	float volts = turretAngleSensor->GetAverageVoltage();
	float invertedVolts = turretAngleSensorInverted->GetAverageVoltage();
	if((volts < .5) || (volts > 4.5) || (invertedVolts < .5) || (invertedVolts > 4.5))
	{
		m_angleInputValid = false;
	}
	else
	{
		m_angleInputValid = true;
	}

	return m_angleInputValid;
}
void TurretWithPID::setTurretMotorOutput(double output){
	float angle = getCurrentAngle();
	if((angle > c_turretAngleMax) && (output < 0)){ 
		turretMotor->Set(output);
	}
	else if((angle < c_turretAngleMin) && (output > 0)){ 
		turretMotor->Set(output);
	}
	else if((angle <= c_turretAngleMax) && (angle >= c_turretAngleMin)){
		turretMotor->Set(output);
	}
	else{
		turretMotor->Set(0);
	}
}
